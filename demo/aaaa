#!/usr/bin/env python3
import argparse
import sqlite3
import zlib
import io

from struct import *

def bit_aligned_bytes(file, offset_bit):
    """
    A generator that yields bytes from a file starting at the offset_bit, but aligned to the start of the byte.
    """
    # Read the first byte, which may need to be shifted
    first_byte = int.from_bytes(file.read(1), byteorder="big")
    shift = offset_bit
    byte = (0xFF >> (8 - shift)) & first_byte
    # Read and yield the remaining bytes
    while True:
        next_byte = int.from_bytes(file.read(1), byteorder="big")
        byte |= ((next_byte << shift) & 0xFF)
        yield byte
        byte = (0xFF >> (8 - shift)) & next_byte

def write(f, i):
    f.write(i.to_bytes(1, 'big'))

def main(source_file, checkpoint_file, block_id):
    # Open the SQLite database with Row as row factory
    conn = sqlite3.connect(checkpoint_file)
    conn.row_factory = sqlite3.Row
    c = conn.cursor()

    # Fetch the row with the specified block_id
    c.execute("SELECT * FROM HuffmanBlock WHERE id = ?", (block_id,))
    row = c.fetchone()
    if row is None:
        print(f"No row found with id {block_id}")
        return

    data = row['data']

    vfile = io.BytesIO()
    # write a noncompressed block with the seed data from the row.
    vfile.write(pack('<B', 0b001))
    vfile.write(pack('<H', len(data)))
    vfile.write(pack('<H', len(data) ^ 0xFFFF))
    vfile.write(data)
    # we're still byte-aligned up to here.
    # Open the source file as a binary file
    with open(source_file, "rb") as f:
        # Seek to the start of the block
        f.seek(row["from_byte"])
        block_len = row["len"]




    result_data = zlib.decompress(vfile.getbuffer(), -15)

    print(result_data)

    # # Open the source file as a binary file
    # with open(source_file, "rb") as f:
    #     # Seek to the start of the block
    #     f.seek(row["from_byte"])
    #     block_len = row["len"]
    #     decompressor = zlib.decompressobj(-15, row["data"])
    #     generator = bit_aligned_bytes(f, row["from_bit"])
    #     data = bytes(next(generator) for _ in range(block_len))
    #     result = decompressor.decompress(data)
    #     print(result)



    # Close the database connection
    conn.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("source_file", help="path to the source file")
    parser.add_argument("checkpoint_file", help="path to the checkpoint file")
    parser.add_argument("block_id", type=int, help="ID of the block to process")
    args = parser.parse_args()
    main(args.source_file, args.checkpoint_file, args.block_id)
